# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Pairwise U-statistic computation
#' @description Computes a U-statistic based on pairwise comparisons of rows in a predictor matrix `x` and response vector `y`.
#' @param x A numeric matrix where each row represents an observation and each column represents a feature.
#' @param y A numeric vector representing the response variable, with length equal to the number of rows in `x`.
#' @return A numeric vector of length equal to the number of columns in `x`, representing the computed U-statistic.
#' @examples
#' \dontrun{
#' # Example data
#' x <- matrix(rnorm(1000), ncol = 5) # 200 rows, 5 columns
#' y <- rnorm(200)
#' # Compute U-statistic
#' u_stat <- un(x, y)
#' print(u_stat)
#' }
#' @export
un <- function(x, y) {
    .Call('_SA24204174_un', PACKAGE = 'SA24204174', x, y)
}

#' @title ReLU Activation Function
#' @description Computes the Rectified Linear Unit (ReLU) activation for a given numeric vector.
#' @param vec A numeric vector (Eigen::VectorXd) for which the ReLU activation is computed.
#' @return A numeric vector (Eigen::VectorXd) with the same dimensions as `vec`, where each element is replaced by `max(0, element)`.
#' @examples
#' \dontrun{
#' # Example vector
#' input_vec <- c(-2, -1, 0, 1, 2)
#' # Compute ReLU
#' output_vec <- relu(input_vec)
#' print(output_vec)  # Should return c(0, 0, 0, 1, 2)
#' }
#' @export
relu <- function(vec) {
    .Call('_SA24204174_relu', PACKAGE = 'SA24204174', vec)
}

#' @title Compute Beta-Hat Vector
#' @description Computes the beta-hat vector using the inverse of the covariance matrix and an input vector.
#' @param sigma A covariance matrix (Eigen::MatrixXd) used in the computation.
#' @param u A numeric vector (Eigen::VectorXd) to be transformed.
#' @return A numeric vector (Eigen::VectorXd) representing the beta-hat, scaled to have a unit norm.
#' @examples
#' \dontrun{
#' n <- 100
#' p <- 5
#' beta_eg <- rep(0.5,p)
#' Sig.X <- diag(rep(1,p))
#' X <- rmvnorm(n.vec[k], rep(0, p), Sig.X)
#' y <- X%*%beta_eg + rnorm (n, 0, 1))
#' u <- un(X,y)
#' betahat(cov(X),u)
#' }
#' @export
betahat <- function(sigma, u) {
    .Call('_SA24204174_betahat', PACKAGE = 'SA24204174', sigma, u)
}

#' @title LMRC Lasso Estimator
#' @description Computes the Lasso estimator using the LMRC method for a given set of parameters.
#' @param n Integer. The number of samples.
#' @param p Integer. The number of predictors (features).
#' @param sigma Eigen::MatrixXd. The covariance matrix of the predictors.
#' @param L Double. The Lipschitz constant for the gradient.
#' @param s Double. Indicator for positive (1) or negative (-1) direction. If 0, computes both and chooses the better one.
#' @param u Eigen::VectorXd. The gradient vector.
#' @param beta_ini Eigen::VectorXd. Initial beta estimate.
#' @param beta_ori Eigen::VectorXd. Original beta estimate.
#' @param w Eigen::VectorXd. A weighting vector.
#' @param lambda Double. Regularization parameter. Default is 0.1.
#' @param alpha Double. Step size parameter. Default is 0.15.
#' @param max_iter Integer. Maximum number of iterations. Default is 100.
#' @param tol Double. Convergence tolerance. Default is 5e-6.
#' @return Eigen::VectorXd. The Lasso beta estimate.
#' @examples
#' \dontrun{
#' n <- 100
#' p <- 50
#' beta_eg <- c(rep(0.5,10),p-10)
#' Sig.X <- diag(rep(1,p))
#' X <- rmvnorm(n.vec[k], rep(0, p), Sig.X)
#' y <- X%*%beta_eg + rnorm (n, 0, 1))
#' L <- 1.0
#' s <- 0
#' u <- un(X,y)
#' beta_ini <- rep(1, p)
#' beta_ori <- rep(0, p)
#' w <- rep(1, p)
#' lambda <- 0.1
#' alpha <- 0.15
#' max_iter <- 100
#' tol <- 5e-6
#' beta_lasso <- lmrc_lasso(n, p, cov(X), L, s, u, beta_ini, beta_ori, w, lambda, alpha, max_iter, tol)
#' print(beta_lasso)
#' }
#' @export
lmrc_lasso <- function(n, p, sigma, L, s, u, beta_ini, beta_ori, w, lambda = 0.1, alpha = 0.15, max_iter = 1e2L, tol = 5e-6) {
    .Call('_SA24204174_lmrc_lasso', PACKAGE = 'SA24204174', n, p, sigma, L, s, u, beta_ini, beta_ori, w, lambda, alpha, max_iter, tol)
}

#' @title LMRC Lasso Debiased Estimator
#' @description Computes a debiased estimator using LMRC Lasso for a given set of parameters.
#' @param n Integer. The number of samples.
#' @param p Integer. The number of predictors (features).
#' @param sigma Eigen::MatrixXd. The covariance matrix of the predictors.
#' @param L Double. The Lipschitz constant for the gradient.
#' @param s Double. Indicator for positive (1) or negative (-1) direction. If 0, computes both and chooses the better one.
#' @param u Eigen::VectorXd. The gradient vector.
#' @param beta_ini Eigen::VectorXd. Initial beta estimate.
#' @param beta_ori Eigen::VectorXd. Original beta estimate.
#' @param w Eigen::VectorXd. A weighting vector.
#' @param denominator Eigen::VectorXd. A denominator vector for scaling.
#' @param lambda Double. Regularization parameter for debiasing. Default is 0.1.
#' @param alpha Double. Step size parameter. Default is 0.15.
#' @param max_iter Integer. Maximum number of iterations. Default is 100.
#' @param tol Double. Convergence tolerance. Default is 5e-6.
#' @param l1_lambda Double. Regularization parameter for L1 penalty. Default is 0.01.
#' @return Eigen::VectorXd. The debiased beta estimate.
#' @examples
#' \dontrun{
#' n <- 100
#' p <- 50
#' beta_eg <- c(rep(0.5,10),p-10)
#' Sig.X <- diag(rep(1,p))
#' X <- rmvnorm(n.vec[k], rep(0, p), Sig.X)
#' y <- X%*%beta_eg + rnorm (n, 0, 1))
#' L <- 1.0
#' u <- un(X,y)
#' ini <- rep(1, p)
#' ori <- rep(0, p)
#' w <- rep(1, p)
#' weight <- rep(1, p)
#' lam1 <- 0.1
#' alpha <- 0.15
#' iter <- 100
#' tol <- 5e-6
#' lam2 <- 0.01
#' s = sign(u[1])
#' bt <- lmrc_lasso_debias(n, p, cov(X), L, s, u, ini, ori, w, weight, lam1, alpha, iter, tol, lam2)
#' cat(bt)
#' }
#' @export
lmrc_lasso_debias <- function(n, p, sigma, L, s, u, beta_ini, beta_ori, w, denominator, lambda = 0.1, alpha = 0.15, max_iter = 1e2L, tol = 5e-6, l1_lambda = 0.01) {
    .Call('_SA24204174_lmrc_lasso_debias', PACKAGE = 'SA24204174', n, p, sigma, L, s, u, beta_ini, beta_ori, w, denominator, lambda, alpha, max_iter, tol, l1_lambda)
}

#' @title Kullback-Leibler (KL) Divergence
#' @description Computes the Kullback-Leibler (KL) divergence between two probability distributions represented by vectors.
#' @param weight A numeric vector (Eigen::VectorXd) representing the posterior distribution (weights).
#' @param prior A numeric vector (Eigen::VectorXd) representing the prior distribution.
#' @return A numeric scalar representing the KL divergence.
#' @examples
#' \dontrun{
#' # Example usage
#' weight <- c(0.4, 0.6)
#' prior <- c(0.5, 0.5)
#' kl_div <- kl(weight, prior)
#' print(kl_div)
#' }
#' @export
kl <- function(weight, prior) {
    .Call('_SA24204174_kl', PACKAGE = 'SA24204174', weight, prior)
}

